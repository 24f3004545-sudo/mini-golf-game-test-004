<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Mini-Golf</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f9;
            color: #333;
        }
        #game-canvas {
            background-color: #2ecc71; /* A nice green for the course */
            border: 5px solid #27ae60;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }
        h1 {
            margin-bottom: 0.5em;
        }
        p {
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <h1>Mini-Golf Challenge</h1>
    <p>Strokes: <span id="strokes-display">0</span></p>
    <canvas id="game-canvas" width="800" height="500"></canvas>

    <script>
        window.onload = function() {
            // --- Canvas & Context Setup ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const strokesDisplay = document.getElementById('strokes-display');

            // --- Game Configuration ---
            const FRICTION = 0.98;
            const POWER_SCALE = 0.1;
            const MIN_VELOCITY = 0.05;

            // --- Game Objects ---
            let ball = {
                x: 100,
                y: canvas.height / 2,
                radius: 12,
                color: '#ffffff',
                vx: 0,
                vy: 0
            };

            const hole = {
                x: canvas.width - 100,
                y: canvas.height / 2,
                radius: 18,
                color: '#000000'
            };

            // --- Game State ---
            let strokes = 0;
            let isAiming = false;
            let isBallMoving = false;
            let aimStart = { x: 0, y: 0 };
            let aimEnd = { x: 0, y: 0 };

            // --- Utility Functions ---
            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function getDistance(p1, p2) {
                return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            }

            // --- Game Logic ---
            function resetGame() {
                strokes = 0;
                strokesDisplay.textContent = strokes;
                ball.x = 100;
                ball.y = canvas.height / 2;
                ball.vx = 0;
                ball.vy = 0;
                isBallMoving = false;
            }

            function update() {
                if (!isBallMoving) return;

                // Apply friction
                ball.vx *= FRICTION;
                ball.vy *= FRICTION;

                // Check if ball has stopped
                if (Math.abs(ball.vx) < MIN_VELOCITY && Math.abs(ball.vy) < MIN_VELOCITY) {
                    ball.vx = 0;
                    ball.vy = 0;
                    isBallMoving = false;
                }

                // Update position
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Wall collisions
                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                    ball.vx *= -1;
                    ball.x = (ball.x + ball.radius > canvas.width) ? canvas.width - ball.radius : ball.radius;
                }
                if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                    ball.vy *= -1;
                    ball.y = (ball.y + ball.radius > canvas.height) ? canvas.height - ball.radius : ball.radius;
                }
                
                // Check for win condition
                const distToHole = getDistance(ball, hole);
                if (distToHole < hole.radius - ball.radius / 2) { // Ball should go in a bit
                    isBallMoving = false;
                    ball.vx = 0;
                    ball.vy = 0;
                    setTimeout(() => {
                        alert(`Congratulations! You finished in ${strokes} strokes.`);
                        resetGame();
                    }, 100);
                }
            }

            // --- Drawing Functions ---
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw hole
                ctx.beginPath();
                ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
                ctx.fillStyle = hole.color;
                ctx.fill();
                ctx.closePath();

                // Draw ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                ctx.closePath();

                // Draw aiming line
                if (isAiming) {
                    ctx.beginPath();
                    ctx.moveTo(ball.x, ball.y);
                    ctx.lineTo(aimEnd.x, aimEnd.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.closePath();
                }
            }

            // --- Event Handlers ---
            canvas.addEventListener('mousedown', (e) => {
                if (isBallMoving) return;

                const mousePos = getMousePos(canvas, e);
                if (getDistance(mousePos, ball) < ball.radius) {
                    isAiming = true;
                    aimStart = { x: ball.x, y: ball.y };
                    aimEnd = mousePos;
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isAiming) return;
                aimEnd = getMousePos(canvas, e);
            });

            canvas.addEventListener('mouseup', (e) => {
                if (!isAiming) return;
                isAiming = false;
                
                const shotPowerX = (aimStart.x - aimEnd.x) * POWER_SCALE;
                const shotPowerY = (aimStart.y - aimEnd.y) * POWER_SCALE;
                
                ball.vx = shotPowerX;
                ball.vy = shotPowerY;
                
                isBallMoving = true;
                strokes++;
                strokesDisplay.textContent = strokes;
            });

            // --- Game Loop ---
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }

            // Start the game
            resetGame(); // To set initial text content
            gameLoop();
        };
    </script>
</body>
</html>